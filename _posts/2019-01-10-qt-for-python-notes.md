---
layout: default
title: "Qt for python beginner notes"
---

Qt for Python is an extension of the classical Qt with C++. It works using the same class structures and syntax adapted to the Python syntax.

# Installation

First of all, the required softwares are:

1. Python version > 3.5
2. pip: This is a tool used to install new packages under the Python environment.
3. Qt (I installed version 5.9.4 and it works but Qt recommends Qt > 5.11. I do not use Qt creator as IDE, I run the scripts from terminal)

Once these softwares are installed (normally they are installed together) just run:
```
pip install PySide2
```
Now the system is ready for creating the Qt for python application it is possible to start developing.

# Qt for python examples

First of all it is important ro remmber to import the `sys` module, otherwise the application cannot be launched correctly.
The core of the python sytem is the following one:
```python
import sys
from PySide2.QtWidgets import QApplication

# Create Qt application
app = QApplication(sys.argv)

# Execute Qt application
sys.exit(app.exec_())
```
To change the font of the Label for example, the API can be found importing `from Qt.Gui import QFont`.
Another important import to have all the standard parameters of Qt is the Qt module itself which can be imported as `from Qt.Core import Qt`.

Some more [examples](https://doc.qt.io/qtforpython/tutorials/index.html#examples-and-demos) are shown on Qt fro python webpage.

Another important aspect to take into consideration is to separate the so called "main" in C++ from the function and classe declaration. This can be done through this statement:
```python
if __name__ == '__main__':
```
In this way the following code can be used as main part of the code.

Some of the important modules to import are the following ones:

* QtCore: Includes all the non graphical function used from other modules
* QtUI: Includes all the base classe for UI components
* QtWidgets: Extend the Qt GUI with C++ widgets

Qt decided to preserve the Qt API, so the camelCase will be used for the Qt part of the code, while the python part use the underscore sepration among different words. So Qt API and documentation are really similar between the python and C++ code.

## Create custom widgets

Custom widgets must begin with the constructor of the new widget which must also call the constructor of the parent class (known as `super()` in python. Then the graphical elemements are created as:

```python
from Pyside2.QtWidgets import QWidget, QPushButton, QLabel, QVboxLayout
from PySide2.QtCore import Slot

class CustomWidget(QWidget):

  # Class constructor
  def __init__(self):
    
    # Parent constructor
    super().__init__(self)
    
    # Create graphical objects
    self.pushButton = QPushBUtton("First push button)
    self.label = QLabel("Fist label")
```

Adding the `self.<objectName>` allows the create th object as class member.

At this point, the graphical objects must be added to a layout which will then be included inside the widget. Indeed, if object are simply created without anchoring them to a layout, they would be piled one another allowing to access only the one on top. This would result in a mess, so an object layout is created and all graphical elements are added in order to give them an order. Eventually, the layout is added to the widget allowing the object to be placed correctly inside the custom widget.

```python
    # Create layout object
    layout = QVBoxLayout()
    
    # Add widgets
    layout.addWidget(slef.pushButton)
    layout.addWidget(self.label)
    
    # Add layout to the widget
    self.setLayout(layout)
```

This is the simple code for creating a custom widget which can be then included inside a window or a dialog.

If the button should do something once pressed, the signal and slots system is adopted. This is done connecting the signal generated by the push button to a function. This can be done in this way:

```python
    # Connect signal and slot
    self.pushButton.clicked.connect(self.magic)
    
    # Connect signal and slot using a lambda function
    self.pushButton.clicked.connect(lambda: print("Button pressed")

    # Not compulsory information. Just for the clarity of the code
    # It tells the developer that here the slot are created
    @Slot() 
    def magic(self):
      print("Button clicked")
```
# Extend C++ application with python

It is possible to extend the C++ applications using Shiboken to convert them in a Cpython file which can be used as python file, adding the desired python functionalities to the already built C++ applications. Using this tool, a library is built and it can be imported inside the python script to access its functionalities. Detailed informations can be found [here](https://doc.qt.io/qtforpython/shiboken2/contents.html).

# Add .ui files to python script

During the Q&A the question emerged and the guy shows taht it is possible. There are 2 ways of doing it, one more simple qhich involves the insertion of a page "as it is", so the window or widget is loaded into the application and run. There is another way which allows to add the page layout and access to the children object in order to perform connect or every operation needed. These methods are explained well on [this web page](https://www.blog.pythonlibrary.org/2018/05/30/loading-ui-files-in-qt-for-python/).

## Load window inside __main__

Using the load function in the main of the script allows only to add the graphical part of the UI, not all the logic which stands behind it. 
>It is important to remember to import the correct module for loading the .ui file as `frmo PySide2.QtUiTools import QUiLoader`.

```python
# Create file object
file = QFile("./prova/mainwindow2.ui")

# Open the file
file.open(QFile.ReadOnly)

# Create .ui file loader
loader = QUiLoader()

# load .ui file and create the window
window = loader.load(file)

# Close file
file.close()

# Show loaded window
window.show()
```

So this could be useful if a merely graphical window must be added to the script. If something must be done with the graphical object this is not suitable for this need.

## Load window inside derived class

Inside a derived class it is possible to load the .ui file in order to build the UI of the window. To do so, the same procedure shown before is possible but then it is possible to go further accessing the children object of the built page. This is an example of code for a QMainWindow derived class:

```python
# Create custom QMainWindow class
class MainWindow(QMainWindow):

    # Class constructor
    def __init__(self, uiFile):

        # Execute parent class constructor
        super().__init__()

        # Create file object
        file = QFile(uiFile)

        # Open the file
        file.open(QFile.ReadOnly)

        # Create .ui file loader
        loader = QUiLoader()

        # Close file
        file.close()

        # load .ui file and create the window
        self.window = loader.load(file)

        # Acces label object
        self.label = self.window.findChild(QLabel, 'label')

        # Change label content
        self.label.setText('Fantastic window created in C++')

        # Access push button object
        self.pushButton = self.window.findChild(QPushButton, 'pushButton')

        # Access table widget
        self.tableWidget = self.window.findChild(QTableWidget, 'tableWidget')

        # Open custom dialog window
        self.pushButton.clicked.connect(self.OpenDialog)

        # Show created window
        self.window.show()

    @ Slot()
    # Slot used when the push button is clicked
    def OpenDialog(self):

        # Create and show modal custom dialog
        dialog = CustomDialog()
        dialog.exec_()
```

This code practically import a QMainWindow derived window and accesses its children objects allowing signal connection and widget modification (as shown here for the push button and for the label respectively). 

The latter syntax could be really useful to obtain a good UI. Indeed this could be tricky considering that python doesn't provide a tool for graphical editing yet. The only way to build an interface in a more straightforward way would be the qml, otherwise the layout must be set up manually.
